#命令模式

命令模式可将“动作的请求者”从“动作的执行”对象中解耦。

>命令模式：将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式
也支持可撤销的操作。


* 一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作
和接收者包进对象中。这个对象只暴露出一个Execute()方法，当此方法被调用的时候，接收者就会
进行相关的动作。从外面来看（动作请求者来看），不知道究竟哪个接收者进行了哪些动作，只知道
如果调用Execute()方法，请求的目的就能达到。
* 一般来说，我们尽量设计“傻瓜”命令对象，它只懂得调用一个接收者的一个行为。
* 要想实现一个多层次的撤销操作，可以使用一个堆栈记录操作过程的每一个命令。然后，不管什么
时候按下撤销按钮，你都可以从堆栈中取出最上层的命令，然后调用他的undo()方法。
* 利用宏命令，你可以动态地决定PartyCommand是由哪些命令组成，使用更灵活，更优雅。

PS:命令模式可以实现灵活配置命令，还可以用作批处理，任务队列，undo,redo

##命令模式用途

1. 队列请求：命令可以将运算块打包（一个接收者和一组动作），然后将它传来传去，就像是一般的对象
一样。现在，即使在命令对象被创建许久之后，运算依然可以被调用。事实上，它甚至可以在不同的线程
中被调用。我们可以利用这些特性衍生出一些应用，如：日程安排（Scheduler）、线程池、工作队列等。
想象有一个工作队列：你在某一端添加命令，然后在另一端则是线程。线程进行下边的动作：从队列中取
出一个命令，调用它的Execute()方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令...

2. 日志请求：某些应用需要我们将所有的动作都记录在日志中，并能在系统死机之后，重新调用这些动作
恢复到之前的状态。通过新增两个方法（store(),load()）,命令模式就能够支持这一点。当我们执行命令
的时候，将历史记录存储在磁盘上，一旦系统死机，我们就可以将命令对象重新加载，并成批地依次调用
这些对象的Execute()方法。有许多调用大型数据结构的动作的应用无法在每次改变发生时被快速地存储。
通过使用记录日志，我们可以将上次检查点（checkpoint）之后的所有操作记录下来，如果系统出现状况，
从检查点开水应用这些操作。如，对应电子表格应用，我们可能想要实现的错误恢复方式是，将电子表格
的操作记录在日志中，而不是每次电子表格一有变化就记录整个电子表格。对高级应用而言，这些技巧可
以被扩展应用到事务（transaction）处理中，也就是说，一整群操作必须全部进行完成，或者没有进行任
何操作。



##要点

* 命令模式将发出请求的对象和执行请求的对象解耦。
* 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个或一组动作。
* 调用者通过调用命令对象的Execute()发出请求，这会使得接收者的动作被调用。
* 命令可以支持撤销，做法是实现一个Undo()方法来回Execute()被执行前的状态。
* 宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。
* 实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者。
* 命令也可以用来实现日志和事务系统。
