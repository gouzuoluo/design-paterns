#工厂

使用new初始化一个类的时候，便是针对实现在编程，这就造成了“耦合”。

##简单工厂

简单工厂看似把一个问题搬到另外一个对象，实则有它的好处，因为SimpleFactory可以有许多的客户，虽然
例子中只有一个客户，而且，把具体实例化的过程从客户的代码中删除了。

把简单工厂定义成一个静态方法是很常见的做法。这样做的优点是，不需要使用创建对象的方法来实例化对象。
缺点是，不能通过继承来改变创建方法的行为。

**go语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。**

**NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。**


> 简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。

##工厂方法

工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象
创建代码解耦了。

所有工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象时什么，来达到将对象创建
的过程封装的目的。

> 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化
推迟到子类。

工厂方法不一定总是抽象的，可以定义一个默认的工厂方法来产生某些具体的产品，这么一来，即使创建者
没有任何子类，依然可以创建产品。

工厂方法和简单工厂看起来很像。子类的确看起来很像一个简单工厂。简单工厂把全部的事情在一个地方都处理
完了，然而工厂方法却是创建一个框架，让子类决定如何实现。


* 设计原则：要依赖抽象，不要依赖具体类（依赖倒置原则）。

PS：
1. 这个原则看起来像“针对接口编程，不针对实现编程”，然而这里更强调“抽象”。这个原则说明了：
不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。

2. 所谓“高层”组件，是由其他底层组件定义其行为的类。如PizzaStore是高层组件，因为它的行为是由披
萨定义的：PizzaStore创建所有不同的披萨对象，准备，烘焙，切片，装盒；而披萨本身属于低层组件。

3. 在“依赖倒置”原则中的倒置，指的是和一般OO设计的思考方式完全相反。即在这一原则下，底层组件依赖
高层的抽象。同样地，高层组件也依赖相同的抽象。

4. 避免在OO设计中违反依赖倒置原则指导：
    * 变量不可以持有具体类的引用。（如果用new，就会持有具体类的引用，可以改用工厂）
    * 不要让类派生自具体类。（如果派生自具体类，你就会依赖具体类，可派生自一个抽象【接口/抽象类】）
    * 不要覆盖基类中已实现的方法。（如果覆盖，你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有子类共享）
    
5.  工厂方法模式使用子类的方式延迟生成对象到子类中实现。Go中不存在继承 所以使用匿名组合来实现。

##抽象工厂

从抽象工厂中派生出一些具体工厂，这些工厂产生相同的产品，但是产品的实现不同。

> 抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

* 抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是
什么。这样一来，客户就从具体的产品中被解耦。
* 抽象工厂的每个方法，经常以工厂方法的方式实现。
* 工厂方法与抽象工厂都是负责创建对象，工厂方法用的是继承，而抽象工厂是通过对象组合。即，利用工厂
方法创建对象，需要扩展一个类，并覆盖它的工厂方法。抽象工厂提供一个用来创建一个产品家族的抽象类型，
这个类型的子类定义了产品被产生的方法。要想使用这个工厂，必须先实例化它，然后将它传入一些针对抽象
类型所写的代码中。
* 工厂方法用来创建一个产品，抽象工厂用来创建整个产品家族。
* 当你需要创建产品家族和想让制造的相关产品集合起来，就用抽象工厂。

##要点

* 所有的工厂（3种）都是用来封装对象的创建。
* 简单工厂虽不是真正的设计模式，但可以将客户程序从具体类中解耦，不失为一个简单的方法。
* 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。
* 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。
* 所有的工厂模式都是通过减少应用程序和具体类之间的依赖促进松耦合。
* 工厂方法允许类将实例化延迟到子类进行。
* 抽象工厂创建相关的对象家族，而不需要依赖他们的具体类。
* 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。
* 工厂是很有威力的技巧，帮助我们针对抽象编程，而不是针对具体类编程。


PS:
* 抽象工厂模式，用于生成产品族的工厂，所生成的对象是有关联的。
* 如果抽象工厂退化成生成的对象无关联，则成为工厂方法模式。


