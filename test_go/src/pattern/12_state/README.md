# 状态模式

策略模式和状态模式是双胞胎，策略模式是围绕可以互换的算法来创建成功业务的。然而，状态
走得是更崇高的路，它通过改变对象内部的状态来帮助对象控制自己的行为。

## 状态机（state machine）

* 状态：
* 动作：
* 如何对对象内的状态建模: 
    1. 首先找出所有的状态；
    2. 然后定义一个实例变量来持有目前的状态，然后定义每个状态的值；
    3. 现在，我们将所有系统中可能发生的动作整合起来。

## 状态模式定义

* 我们把一个状态的所有行为放在一个类中，这样一来，我们将行为局部化了，如果我们针对
某个状态做了改变，就不会把其他的代码给搞乱了。同时，当我们加入新的状态时，改变代码也
更容易，且更不容易出错。

* 如果我们将每个状态的行为都放在各自的类中，那么每个状态只要实现它自己的动作就可以了。

> 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

* 这个模式将状态封装成为独立的类，并将动作委托到代表当前状态的对象，行为会随着内部状态而改变。

* 策略模式和状态模式的类图是一模一样，但这两个模式的差别就在于他们的“意图”：
    1. 就状态模式而言，我们将一群行为封装在状态对象中，“Context”的行为随时可委托到那些状态对象
    中的一个。随着行为的变化，当前状态在状态对象集合中游走改变，以反映出“Context”内部的状态，
    “Context”的行为也会跟着改变。但是“Context”的客户对于状态对象了解不多，甚至根本是浑然不觉。
    
    2. 而策略模式而言，客户通常主动指定"Context"所要组合的策略对象是哪一个。

* 一般来说，我们把策略模式想象成是除了继承之外的一种弹性替代方案，如果你使用继承定义了一个类的行为，
你将被这个行为困住，甚至要修改它都很困难。有了策略模式，你可以通过组合不同的对象来改变行为。

* 我们把状态模式想象成是不用在“Context”中放置许多条件判断的替代方案。通过将行为包装进状态对象中，
你可以通过在“Context”内简单地改变状态对象来改变“Context”的行为。

* 在GumballMachine中，状态决定了下一个状态应该是什么，ConcreteState决定了接下来的状态是什么。但并非
总是如此，Context也可以决定状态转换的流向。一般来讲，当状态转换是固定的时候，就适合放在Context中；
然而，当转换是更动态的时候，通常就会放在状态类中（如，在GumballMachine中，由运行时糖果的数目来决定
状态要转换到NoQuarter还是SoldOut）。

* 将状态转换放在状态类中的缺点是：状态类之间产生了依赖。在我们的GumballMachine实现中，我们试图通过
使用Context上的getter方法把依赖减小到最小，而不是显示硬编码具体状态类。请注意，在做这个决策的同时，
也等于是在为另外一件事情做决策：当系统进化时，究竟哪个类是对修改封闭（Context还是状态类）的。


## 模式对比

* 策略模式：将可以互换的行为封装起来，然后使用委托的方法，决定使用哪一个行为。
* 模板方法：由子类决定如何实现算法中的某些步骤。
* 状态模式：封装基于状态的行为，并将行为委托到当前状态。


## 要点

* 状态模式允许一个对象基于内部状态而拥有不同的行为。

* 和程序状态机（PSM）不同，状态模式用类代表状态。

* Context会将行为委托给当前状态对象。

* 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了。

* 策略模式通常用行为或算法来配置Context类。

* 状态模式允许Context随着状态的改变而改变行为。

* 状态转换可以由State类或Context类控制。

* 使用状态模式通常会导致设计中类的数目大量增加。

* 状态类可以被多个Context实例共享。