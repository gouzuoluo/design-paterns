# 迭代器（Iterator）

1. 迭代器模式提供一种方法，顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

2. 实现方式：每一个具体聚合都要负责实例化一个具体迭代器，此迭代器能够遍历对象集合。

3. 迭代器让我们能够遍历聚合中的每个元素，而不去强迫聚合必须提供方法，让我们在它的元素中游走。
我们可以在聚合外面实现迭代器。换句话说，我们封装了遍历。

PS：在多线程中的代码中使用迭代器时，必须特别小心。尤其是提供Remove方法的迭代器。

## 定义

>迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。

* 外部迭代器（eg1,eg2）：客户通过调用Next取得下一个元素。

* 内部迭代器：由迭代器自己控制迭代过程。在这种情况下，因为是由迭代器自行在元素之间游走，所
以你必须告诉迭代器周游的过程中，要做些什么事情，即，你必须将操作指令传入给迭代器。因为客户
无法控制遍历的过程，所以内部迭代器比外部迭代器更没有弹性。然而，某些人可能认为内部迭代器比
较容易使用，因为只需要将操作告诉它，它就会帮你完成所有事情。（go库sync.map提供Range遍历方式）

* 迭代器意味着没有次序。对于迭代器来说，数据结构可以是有次序的，或是没有次序的，甚至可以是
重复的。除非某个集合的文件有特别说明，否则不可以对迭代器所取出的元素大小顺序做假设。

* 迭代器模式用于使用相同的方式迭代不同类型集合，或者隐藏集合类型的具体实现。

* 可以使用迭代器模式使遍历的同时应用迭代策略，如请求新的对象、过滤、处理对象等。

## 单一责任原则

设计原则9：一个类应该只有一个引起变化的原因（单一责任原则，高内聚）。

如果我们允许我们的聚合实现他们内部的集合，以及相关的操作和遍历方法，这就是说，我们允许一个
类不但要完成自己的事情（管理某种聚合），还同时要担负更多的责任（如遍历）时，我们就给了这个
类两个变化的原因。如果这个集合改变的话，这个类必须改变；如果我们遍历方式改变的话，这个类
也必须跟着改变。因为修改代码容易造成许多潜在的错误。如果一个类具有2个改变的原因，那么这会
使得改变该类的变化几率上升。

* 尽量让每个类保持单一责任。

* 当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成
支持一组不相关的功能时，我们说它具有低内聚。


## 要点

* 迭代器允许访问聚合的元素，而不需要暴露它的内部结构。

* 迭代器将遍历聚合的工作封装进一个对象中。

* 当使用迭代器的时候，我们依赖聚合提供遍历。

* 迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制。

* 我们应该努力让一个类只分配一个责任。