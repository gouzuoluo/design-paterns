package main

import "fmt"

/*

<<     左移
>>     右移
&      位运算 AND
|      位运算 OR
^      位运算 XOR  【既可作为单目运算符——按位取反，也可作为双目运算符——异或运算】
&^     位清空 (AND NOT)

PS:位清空：和被运算变量位置有关系：x &^ y == x &(^y)，如果y bit位上的数是0则取x上对应位置的值，
如果y bit位上为1则结果位上取0，即：用一个操作数y来对需要被未清空的x进行操作。


感觉位运算操作符虽然在平时用得并不多，但是在涉及到底层性能优化或者使用某些trick的时候还是比较有意思。

(1)&(AND) |(OR) 就不提了最常用的东西 会编程就会。

(2)&操作的话是当 两个数需要同时为1的时候才会保留。 例如 0000 0100 & 0000 1111 => 0000 0100 => 4

(3)|操作的话是当 两个数同时为1或者1个为1一个不为1的时候会保留。 例如 0000 0100 | 0000 1111 => 0000 1111 => 15

(4)^(XOR) 在go语言中XOR是作为二元运算符存在的(相同为0，不同为1),但是如果是作为一元运算符出现，他的意思是按位取反(c++取反为~，异或为^)，例如


PS:二进制数在内存中以补码的形式存储。例如：
^9的计算步骤：
转二进制：0 1001
计算补码：0 1001

按位取反：1 0110（取反操作后的形式）

转为原码：

按位取反：1 1001
末位加 1：1 1010
符号位为1是负数，即-10

原码：
反码：正整数的反码与原码相同，负整数的反码为符号位1不变，数值部分按位取反
补码：正整数的补码与原码相同，负整数的补码为符号位1不变，数值部分按位取反，最后再加1（即，反码加1）
*/

func main() {
	//x := int(9) //0 1001（符号位 ）
	//fmt.Println(^x)

	//x := 4
	//y := 2
	//fmt.Println(x^y)

	x := 2
	y := 4
	fmt.Println(x &^ y) //x &^ y == x &(^y)
}
